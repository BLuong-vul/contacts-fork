<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReplyService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java in middleware Coverage Results</a> &gt; <a href="index.source.html" class="el_package">com.vision.middleware.service</a> &gt; <span class="el_source">ReplyService.java</span></div><h1>ReplyService.java</h1><pre class="source lang-java linenums">package com.vision.middleware.service;

import com.vision.middleware.domain.ApplicationUser;
import com.vision.middleware.domain.Post;
import com.vision.middleware.domain.Reply;
import com.vision.middleware.domain.relations.UserVote;
import com.vision.middleware.dto.ReplyDTO;
import com.vision.middleware.dto.UserDTO;
import com.vision.middleware.exceptions.IdNotFoundException;
import com.vision.middleware.repo.ReplyRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ReplyService {

    private static final int MAX_REPLY_LENGTH = 5000;
    private static final int MAX_NESTING_DEPTH = 100;

    @Autowired
    private final ReplyRepository replyRepository;

    @Autowired
    private final VotingService votingService;

    // null parent reply if this is supposed to be a root reply.
    @Transactional
    public Reply createReply(Post post, ApplicationUser author, String text, Reply parentReply) {
<span class="fc" id="L38">        validateReply(text, parentReply);</span>

<span class="fc" id="L40">        Reply reply = Reply.builder()</span>
<span class="fc" id="L41">                .post(post)</span>
<span class="fc" id="L42">                .author(author)</span>
<span class="fc" id="L43">                .text(text)</span>
<span class="fc" id="L44">                .parentReply(parentReply)</span>
<span class="fc" id="L45">                .datePosted(new Date())</span>
<span class="fc" id="L46">                .likeCount(0L)</span>
<span class="fc" id="L47">                .dislikeCount(0L)</span>
<span class="fc" id="L48">                .voteScore(0L)</span>
<span class="fc" id="L49">                .build();</span>

<span class="fc bfc" id="L51" title="All 2 branches covered.">        if (parentReply != null) {</span>
            // JPA automatically cascades change to parents when calling save later on child. (CascadeType.ALL on childReplies)
<span class="fc" id="L53">            parentReply.addChildReply(reply);</span>
        }

<span class="fc" id="L56">        return replyRepository.save(reply);</span>
    }

    public Reply findReplyById(long replyId) {
<span class="fc" id="L60">        return replyRepository.findById(replyId).orElseThrow(</span>
<span class="fc" id="L61">                () -&gt; new IdNotFoundException(String.format(&quot;Reply with id %d not found.&quot;, replyId))</span>
        );
    }

    public void voteOnReply(ApplicationUser user, Reply reply, UserVote.VoteType voteType) {
<span class="fc" id="L66">        votingService.voteOnVotable(user, reply, voteType);</span>
<span class="fc" id="L67">    }</span>

    @Transactional
    public void deleteReply(Reply reply) {
<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (!reply.getChildReplies().isEmpty()) {</span>
            // preserve tree structure
<span class="fc" id="L73">            reply.softDelete();</span>
<span class="fc" id="L74">            replyRepository.save(reply);</span>
        } else {
            // delete that thing. Update parent that we are removing one of its children as well.
<span class="fc" id="L77">            Reply parentReply = reply.getParentReply();</span>
<span class="fc" id="L78">            parentReply.removeChildReply(reply);</span>
<span class="fc" id="L79">            replyRepository.save(parentReply);</span>

<span class="fc" id="L81">            replyRepository.delete(reply);</span>
        }
<span class="fc" id="L83">    }</span>

    public List&lt;ReplyDTO&gt; getCommentTreeForPost(Long postId, ApplicationUser currentUser) {
<span class="fc" id="L86">        List&lt;Reply&gt; topLevelReplies = replyRepository.findTopLevelRepliesByPostId(postId);</span>
<span class="fc" id="L87">        return topLevelReplies.stream()</span>
<span class="fc" id="L88">                .map(reply -&gt; convertToCommentTree(reply, currentUser))</span>
<span class="fc" id="L89">                .collect(Collectors.toList());</span>
    }

    private ReplyDTO convertToCommentTree(Reply reply, ApplicationUser currentUser) {
        // Get the user's vote on this reply if it exists
<span class="fc" id="L94">        Optional&lt;UserVote.VoteType&gt; userVoteType = votingService.getUserVoteOnVotable(currentUser, reply);</span>

        // Convert child replies recursively
<span class="fc" id="L97">        List&lt;ReplyDTO&gt; childComments = reply.getChildReplies().stream()</span>
<span class="fc" id="L98">                .sorted(Comparator</span>
<span class="fc" id="L99">                        .comparingLong(Reply::getVoteScore).reversed()</span>
<span class="fc" id="L100">                        .thenComparing(Reply::getDatePosted).reversed()) // Note the reversed() for date</span>
<span class="fc" id="L101">                .map(childReply -&gt; convertToCommentTree(childReply, currentUser))</span>
<span class="fc" id="L102">                .collect(Collectors.toList());</span>

        // Build author DTO
<span class="fc" id="L105">        UserDTO author = UserDTO.builder()</span>
<span class="fc" id="L106">                .userId(reply.getAuthor().getId())</span>
<span class="fc" id="L107">                .username(reply.getAuthor().getUsername())</span>
<span class="fc" id="L108">                .displayName(reply.getAuthor().getDisplayName())</span>
<span class="fc" id="L109">                .profilePictureFileName(reply.getAuthor().getProfilePictureFileName())</span>
<span class="fc" id="L110">                .build();</span>

        // Build the comment tree DTO
<span class="fc" id="L113">        return ReplyDTO.builder()</span>
<span class="fc" id="L114">                .id(reply.getId())</span>
<span class="fc" id="L115">                .text(reply.getText())</span>
<span class="fc" id="L116">                .author(author)</span>
<span class="fc" id="L117">                .datePosted(reply.getDatePosted())</span>
<span class="fc" id="L118">                .likeCount(reply.getLikeCount())</span>
<span class="fc" id="L119">                .dislikeCount(reply.getDislikeCount())</span>
<span class="fc" id="L120">                .voteScore(reply.getVoteScore())</span>
<span class="fc" id="L121">                .userVoteType(userVoteType.orElse(null))</span>
<span class="fc" id="L122">                .isDeleted(reply.isDeleted())</span>
<span class="fc" id="L123">                .replies(childComments)</span>
<span class="fc" id="L124">                .build();</span>
    }

    private void validateReply(String text, Reply parentReply) {
<span class="fc" id="L128">        validateReplyLength(text);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (parentReply != null) {</span>
<span class="fc" id="L130">            validateNestingDepth(parentReply);</span>
        }
<span class="fc" id="L132">    }</span>

    private void validateReplyLength(String text) {
<span class="pc bpc" id="L135" title="1 of 4 branches missed.">        if (text == null || text.trim().isEmpty()) {</span>
<span class="fc" id="L136">            throw new IllegalArgumentException(&quot;Reply text cannot be empty&quot;);</span>
        }
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (text.length() &gt; MAX_REPLY_LENGTH) {</span>
<span class="fc" id="L139">            throw new IllegalArgumentException(</span>
<span class="fc" id="L140">                    String.format(&quot;Reply text exceeds maximum length of %d characters&quot;, MAX_REPLY_LENGTH)</span>
            );
        }
<span class="fc" id="L143">    }</span>

    private void validateNestingDepth(Reply parentReply) {
<span class="fc" id="L146">        int depth = calculateDepth(parentReply);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (depth &gt;= MAX_NESTING_DEPTH) {</span>
<span class="fc" id="L148">            throw new IllegalArgumentException(</span>
<span class="fc" id="L149">                    String.format(&quot;Maximum nesting depth of %d exceeded&quot;, MAX_NESTING_DEPTH)</span>
            );
        }
<span class="fc" id="L152">    }</span>

    private int calculateDepth(Reply reply) {
<span class="fc" id="L155">        int depth = 0;</span>
<span class="fc" id="L156">        Reply current = reply;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        while (current.getParentReply() != null) {</span>
<span class="fc" id="L158">            depth++;</span>
<span class="fc" id="L159">            current = current.getParentReply();</span>
        }
<span class="fc" id="L161">        return depth;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>